#![cfg_attr(not(feature = "std"), no_std)]

//FELIX REVIEW: Eventually it will be nice to have a short introduction here explaining what this pallet does and the
// avaliable methods etc.

pub use pallet::*;
//pub mod impls;
pub mod traits;
pub mod weights;
use core::fmt::Debug;
use frame_support::{pallet_prelude::*, weights::Weight};

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame_support::pallet]
pub mod pallet {
    use super::*;
    use codec::{FullCodec, FullEncode};
    use frame_system::pallet_prelude::*;
    use sp_runtime::traits::AtLeast32BitUnsigned;
    use traits::DisputeHooks;

    #[pallet::pallet]
    pub struct Pallet<T>(_);

    pub(crate) type AccountIdOf<T> = <T as frame_system::Config>::AccountId;

    #[pallet::config]
    //FELIX Review: Comment each of the config items so we know exactly what they are doing.
    pub trait Config: frame_system::Config {
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        // The weights generated by the benchmarks.
        type WeightInfo: WeightInfoT;
        //Felix teachings --> to keep an associated type into storage it needs to implement certain traits
        type DisputeKey: AtLeast32BitUnsigned
            + FullEncode
            + FullCodec
            + MaxEncodedLen
            + TypeInfo
            + Debug;
        //This is the max length for specifying the reason while raising the dispute
        type MaxReasonLength: Get<u32>;
        //This is number of juries that can be assigned to a given dispute
        type MaxJurySize: Get<u32>;

        type DisputeHooks: traits::DisputeHooks<Self::DisputeKey>;
        type TimeLimit: Get<<Self as frame_system::Config>::BlockNumber>;
        type AuthorityOrigin: EnsureOrigin<Self::RuntimeOrigin>;
    }

    //Used to store the disputes that is being raised, given the dispute key it returns the Dispute
    #[pallet::storage]
    #[pallet::getter(fn disputes)]
    pub type Disputes<T: Config> =
        StorageMap<_, Blake2_128Concat, T::DisputeKey, Dispute<T>, OptionQuery>;

    #[pallet::event]
    // FELIX REVIEW: the below generate_deposit line is depricated in the 9.0.43 so you can remove it completely.
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        //This event is emitted whenever a dispute has been successfully raised
        DisputeRaised { who: AccountIdOf<T> },
        // This event is emitted whenever there has been a voting successfully happened for a given dispute by
        // the authorized jury member
        DisputeVotedOn { who: AccountIdOf<T> },
        //This event is emitted when the dispute is being cancelled
        DisputeCompleted,
        //This event is emitted when the dispute is being cancelled
        DisputeCancelled,
    }

    #[pallet::error]
    pub enum Error<T> {
        //When there is no value present
        NoneValue,
        //Whenever we try to insert the storage beyond its bounded capacity
        StorageOverflow,
        //This error is thrown whenever the dispute key passed doesn't correspond to any dispute
        DisputeDoesNotExist,
        DisputeAlreadyExists,
        //wrong jury trying to vote
        InvalidJuryAccount,
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        #[pallet::call_index(0)]
        // FELIX: BENCHMARK
        #[pallet::weight(<T as Config>::WeightInfo::vote_on_dispute())]
        pub fn vote_on_dispute(
            origin: OriginFor<T>,
            dispute_key: T::DisputeKey,
            vote: Vote,
        ) -> DispatchResult {
            // get dispute struct
            // ensure caller is part of the jury
            // mutate vote accordingly.
            let who = ensure_signed(origin)?;

            //iterate over the disputes and update the voting state based on the passed vote
            //SHANKAR I was thinking of returning out the updated vote to calculate the finalization?
            // FELIX REVIEW: for now leave it, and allow votes to be mutable
            Disputes::<T>::try_mutate(dispute_key, |dispute| {
                if let Some(d) = dispute {
                    ensure!(
                        d.jury.iter().any(|e| e == &who),
                        Error::<T>::InvalidJuryAccount
                    );
                    // FELIX REVIEW:
                    // This doesnt work, notice how a vote isnt mutable, therefore you arnt mutating it at all.
                    // Also how do you account for changing of a vote
                    let  vote = &d.votes;
                    match vote {
                        Vote::Refund(mut refund) => {
                            refund.update_refund_votes(refund.to_initiator, refund.to_refund);
                        }
                        Vote::Continue => {
                            println!("Vote: Continue");
                        }
                        Vote::Abstain => {
                            println!("Vote: Abstain");
                        }
                    }



                    Ok(())
                } else {
                    Err(Error::<T>::DisputeDoesNotExist)
                }
            });

            Self::deposit_event(Event::<T>::DisputeVotedOn { who });
            Ok(().into())
        }

        #[pallet::call_index(1)]
        // FELIX REVIEW: Benchmarks
        #[pallet::weight(<T as Config>::WeightInfo::force_cancel_dispute())]
        pub fn force_cancel_dispute(
            origin: OriginFor<T>,
            dispute_key: T::DisputeKey,
            is_yay: bool,
        ) -> DispatchResult {
            //ensuring the cancelling authority
            <T as Config>::AuthorityOrigin::ensure_origin(origin)?;
            //calling the on_dispute cancel whenever the force cancel method is called
            <Self as DisputeHooks<T::DisputeKey>>::on_dispute_cancel(dispute_key);
            Ok(().into())
        }
    }

    #[derive(Encode, Decode, PartialEq, Eq, Clone, Debug, TypeInfo, MaxEncodedLen)]
    #[scale_info(skip_type_params(T))]
    pub struct Dispute<T: Config> {
        pub raised_by: AccountIdOf<T>,
        pub fund_account: AccountIdOf<T>,
        // TODO: Add balance type
        // currencyid: CurrencyId
        //fund_amount: BalanceOf<T>
        pub votes: Vote,
        pub reason: BoundedVec<u8, <T as Config>::MaxReasonLength>,
        pub jury: BoundedVec<AccountIdOf<T>, <T as Config>::MaxJurySize>,
    }

    #[derive(Encode, Decode, PartialEq, Eq, Clone, Debug, TypeInfo, MaxEncodedLen)]
    pub enum Vote {
        Refund(RefundVote),
        Continue,
        Abstain,
    }

    // A dispute vote contains what an account believes the outcome should be.
    #[derive(Encode, Decode, PartialEq, Eq, Clone, Copy,Debug, TypeInfo, MaxEncodedLen)]
    pub struct RefundVote{
        pub to_initiator: u32,
        pub to_refund: u32,
    }

    impl RefundVote {
        fn update_refund_votes(&mut self, total_to_initiator: u32, total_to_refund: u32) {
            self.to_initiator += total_to_initiator;
            self.to_refund += total_to_refund;
        }
    }

    enum Outcome {
        Refund,
        Continue,
        Slash,
    }
}

pub trait WeightInfoT {
    fn vote_on_dispute() -> Weight;
    fn force_cancel_dispute() -> Weight;
    fn raise_dispute() -> Weight;
    fn on_dispute_complete() -> Weight;
    fn on_dispute_cancel() -> Weight;
}
